## 모듈과 의존성

어플리케이션은 여러 컴포넌트들의 결합된 결과. 이에 따라 각각의 컴포넌트의 연결 방식이 중요.
얽힌 종속성 그래프는 기술적 부채를 늘리며, 확장을 막는다. 따라서 확장성 등을 고려하여 구현해야 한다.

노드는 Common JS를 통한 모듈 시스템을 통해 이를 해소할 수 있도록 돕는다.
이에 더하여 종속성 연결 을 통하여 더 엄격한 결합을 생성할 수 있다.

### 종속성

컴포넌트의 동작이나 구조에 영향을 미치는 엔티티, 상태 또는 데이터 형식을 종속성으로 간주할 수 있다.

> A 컴포넌트가 B 컴포넌트가 제공하는 서비스를 사용한다던가, 시스템 특정 전역 상태에 의존하거나, 특정 통신 프로토콜을 구현하는 등의 경우가 있다.

### 모듈

노드에서 모듈은 필수 유형 종속성을 식별하고 코드를 구성 및 구조화하는데 필요한 기본적 메커니즘 이다.

- 집중적으로 코드의 가독성과 이해를 높인다.
- 식별이 쉽다.
- 재사용이 쉽다.

### 모놀리식 과 마이크로 서비스

모듈관의 관계가 매우 강한 모놀리식 개체는 아키텍처 전부를 흔들 수 있다.

> 그렇다고 마이크로 서비스가 무조건 좋은 것도 아니다.

### 응집력과 결합력

결국, 모듈을 생성할 때 응집력과 결합력의 균형을 이루어 구축하는 것이 효과적 이다.
바람직한 형태는 높은 응집도와 느슨한 결합을 갖는 구조다. 이는 이해하기 쉽고 재사용 가능하며 확장 가능한 모듈을 만든다.

> 높은 응집도 : 컴포넌트 기능 간의 상관 관계 에 대한 측도. 단 한가지의 작업만 하는 모듈은 모듈의 모든 부분이 하나의 단일 업무 에서만 역할을 할 경우 높은 응집력을 갖는다.

> 느슨한 결합 : 구성 요소가 시스템의 다른 구성 요소에 얼마나 의존하는지에 대한 측도. 두 모듈이 매개 변수를 통해서만 통신 한다면 느슨한 결합이라 할 수 있다.

## Node의 싱글톤 패턴

어떻게 싱글톤 패턴을 올바르게 구현할 것인가?

> 단순히 module.exports 를 사용하여 인스턴스를 내보는 것 만으로 싱글톤 패턴과 비슷한 것을 얻을 수 있다.
> 다만, node_modules 특성 상 동일한 모듈의 다른 인스턴스가 발생할 수 있어, 주의해야 한다.

## 모듈 연결 패턴

상태저장(stateful) 인스턴스의 연결(wiring)

### 하드코딩된 종속성

Node에서 클라이언트 모듈이 require()를 사용하여 다른 모듈을 명시적으로 로드할 때 발생하는 의존성 입니다.
간단하고 효과적이나, 재사용을 제한하기 때문에 상태 저장(stateful) 인스턴스(DB 등)와 종속성을 하드코딩 할 때는 주의를 기울여야 합니다.

하드코딩된 종속성 사용의 단점은 대부분 상태유지 인스턴스와 관련되어 있다.
상태가 없는 모듈을 로드할 경우, 재사용성에 영향을 주지 않는다.

---

### 의존성 주입(DI)

<b>DI 패턴의 주요 아이디어는 컴포넌트의 종속성들을 외부 개체에 의해 입력으로 제공하는 것.</b>

DI를 활용하여 각 종속성은 모듈에 하드코딩 되지 않고 외부에서 수신하게 된다. 이러한 개체는 시스템의 모든 모듈을 중앙 집중화 하는 클라이언트 컴포넌트 또는 전역 컨테이너 일 수 있다. 이 접근법의 가장 큰 장점은 상태 저장 인스턴스 모듈에 대해 디커플링이 향샹된다.

즉 모듈이 어떤 종속성이든 사용하도록 설정할 수 있으므로, 다른 컨텍스트에서 재사용할 수 있다.

---

### 그러면?

위에 하드코딩 된 상태저장 인스턴스를 일련의 종속성을 인수로 취하는 팩토리를 생성하여 리팩토링 할 수 있다.
